# -*- coding: utf-8 -*-
"""Clustering.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1okLs-SFPUsqehPNRLF_3EG-Y-ZzfMsKF

UCI Dataset HTRU : https://archive.ics.uci.edu/dataset/372/htru2

Library
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.cluster import AgglomerativeClustering
from sklearn.preprocessing import StandardScaler, normalize
from sklearn.metrics import silhouette_score
import scipy.cluster.hierarchy as shc
import seaborn as sns
from sklearn.cluster import DBSCAN
from sklearn import metrics
from sklearn.preprocessing import StandardScaler
from sklearn import datasets
from sklearn.metrics import f1_score, classification_report
from sklearn.metrics import confusion_matrix

"""# Import Dataset

Import dataset
"""

# import dataset
X = pd.read_csv('HTRU_2.csv')
ground_truth_labels = X.iloc[:, -1]
X = X.drop(columns=[X.columns[-1]])

header_info = [
    "Profile_mean", "Profile_stdev", "Profile_skewness", "Profile_kurtosis", "DM_mean", "DM_stdev", "DM_skewness", "DM_kurtosis"
]
X.columns = header_info

# X_DBSCAN = X[["Profile_mean",'Profile_stdev',"DM_mean",'DM_stdev']]
X_DBSCAN = X.copy()

# Handling the missing values
X.fillna(method ='ffill', inplace = True)

X

X.describe()

X.info()

# Scaling the data so that all the features become comparable
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Normalizing the data so that the data approximately
# follows a Gaussian distribution
X_normalized = normalize(X_scaled)

# Converting the numpy array into a pandas DataFrame
X_normalized = pd.DataFrame(X_normalized)

pca = PCA(n_components = 2)
X_principal = pca.fit_transform(X_normalized)
X_principal = pd.DataFrame(X_principal)
X_principal.columns = ['P1', 'P2']

X_DBPCA = X_principal.copy()

X_principal

cumulative_variance = np.cumsum(pca.explained_variance_ratio_)
cumulative_variance

# Plot cumulative explained variance
plt.plot(cumulative_variance, marker='o', linestyle='-', color='b')
plt.xlabel('Number of Components')
plt.ylabel('Cumulative Explained Variance')
plt.title('Explained Variance vs. Number of Components')
plt.grid(True)
plt.show()

"""# Agglomerative Clustering"""

# dendrogram
plt.figure(figsize =(8, 8))
plt.title('Visualising the data')
Dendrogram = shc.dendrogram((shc.linkage(X_principal, method ='ward')))

"""**Cluster Agglomerative**"""

def bar(labels, counts):
  # Membuat bar plot
  plt.bar(labels, counts, color=plt.cm.rainbow(np.linspace(0, 1, len(labels))))
  plt.title("Distribution Of The Clusters")
  plt.xlabel("Cluster Labels")
  plt.ylabel("Count")
  plt.xticks(labels)  # Set x-ticks sesuai dengan label yang unik
  plt.show()

agglo_labels = []
agglo_dbIndex = []

for cluster in range(2,7):
  print("Cluster ", cluster)
  ac2 = AgglomerativeClustering(n_clusters = cluster)
  agglomerative_labels = ac2.fit_predict(X_principal)
  agglomerative_score = silhouette_score(X_principal, agglomerative_labels)
  agglo_labels.append(agglomerative_labels)
  # Visualizing the clustering
  plt.figure(figsize =(6, 6))
  plt.scatter(X_principal['P1'], X_principal['P2'],
            c = agglomerative_labels, cmap ='rainbow')
  plt.show()

  # Menghitung Davies-Bouldin Index
  db_index = davies_bouldin_score(X_principal, agglomerative_labels)
  agglo_dbIndex.append(db_index)
  print("Davies-Bouldin Index:", db_index)

  # Menghitung jumlah kemunculan setiap label
  unique_labels, counts = np.unique(agglomerative_labels, return_counts=True)
  bar(unique_labels,counts)

  # Menghitung Variance untuk setiap cluster
  variance_list = []
  for label in unique_labels:
      cluster_points = X_principal[agglomerative_labels == label]
      centroid = cluster_points.mean(axis=0)
      variance = np.mean(np.sum((cluster_points - centroid) ** 2, axis=1))
      variance_list.append(variance)

  print(f'Variance for {cluster} clusters: {variance_list}')
  print(f'Average Variance: {np.mean(variance_list)}')

k = [2, 3, 4, 5, 6]

# menggabungkan silhouette score setiap cluster
silhouette_scores = []
silhouette_scores.append(
        silhouette_score(X_principal, agglo_labels[0]))
silhouette_scores.append(
        silhouette_score(X_principal, agglo_labels[1]))
silhouette_scores.append(
        silhouette_score(X_principal, agglo_labels[2]))
silhouette_scores.append(
        silhouette_score(X_principal, agglo_labels[3]))
silhouette_scores.append(
        silhouette_score(X_principal, agglo_labels[4]))

# Plotting graph untuk membandingkan cluster n 2-6
plt.bar(k, silhouette_scores)
plt.xlabel('Number of clusters', fontsize = 20)
plt.ylabel('S(i)', fontsize = 20)
plt.show()

print("Agglomerative Silhouette Score : ",silhouette_scores)

# Plotting graph untuk membandingkan cluster n 2-6
plt.bar(k, agglo_dbIndex)
plt.xlabel('Number of clusters', fontsize = 20)
plt.ylabel('DB Index', fontsize = 20)
plt.show()

# X_principal["Clusters"] = agglomerative_labels
# #Adding the Clusters feature to the orignal dataframe.
# X["Clusters"] = agglomerative_labels
AGG_clustered = X_principal.copy()
AGG_clustered.loc[:,'Cluster'] = agglo_labels[1] # menggabungkan label ke DF
AGG_clust_sizes = AGG_clustered.groupby('Cluster').size().to_frame()
AGG_clust_sizes.columns = ["AGG_size"]
AGG_clust_sizes

# Calculate F-measure using 'macro' average
f_measure_weighted_agglo = f1_score(ground_truth_labels, agglomerative_labels, average='weighted')
print("F-measure (weighted):", f_measure_weighted_agglo)

report_agglo = classification_report(ground_truth_labels, agglomerative_labels)

print("Report:")
print(report_agglo)

"""# DBSCAN Clustering

**DBSCAN**
"""

X_DBSCAN.head()

from itertools import product

eps_values = np.arange(8,12.75,0.25) # eps values to be investigated
min_samples = np.arange(3,10) # min_samples values to be investigated

DBSCAN_params = list(product(eps_values, min_samples))

# from sklearn.metrics import silhouette_score

# no_of_clusters = []
# sil_score = []

# for p in DBSCAN_params:
#     DBS_clustering = DBSCAN(eps=p[0], min_samples=p[1]).fit(X_DBSCAN)
#     no_of_clusters.append(len(np.unique(DBS_clustering.labels_)))
#     sil_score.append(silhouette_score(X_DBSCAN, DBS_clustering.labels_))

from sklearn.metrics import davies_bouldin_score
from sklearn.metrics import silhouette_score

no_of_clusters = []
sil_score = []
db_index = []

for p in DBSCAN_params:
    # Melakukan clustering dengan DBSCAN
    DBS_clustering = DBSCAN(eps=p[0], min_samples=p[1]).fit(X_DBSCAN)

    # Menghitung jumlah cluster
    no_of_clusters.append(len(np.unique(DBS_clustering.labels_)))

    # Menghitung Silhouette Score
    sil_score.append(silhouette_score(X_DBSCAN, DBS_clustering.labels_))

    # Menghitung Davies-Bouldin Index
    db_index.append(davies_bouldin_score(X_DBSCAN, DBS_clustering.labels_))

# Menampilkan hasil evaluasi
print("Jumlah Cluster:", no_of_clusters)
print("Silhouette Score:", sil_score)
print("Davies-Bouldin Index:", db_index)

tmp = pd.DataFrame.from_records(DBSCAN_params, columns =['Eps', 'Min_samples'])
tmp['No_of_clusters'] = no_of_clusters

pivot_1 = pd.pivot_table(tmp, values='No_of_clusters', index='Min_samples', columns='Eps')

fig, ax = plt.subplots(figsize=(12,6))
sns.heatmap(pivot_1, annot=True,annot_kws={"size": 16}, cmap="YlGnBu", ax=ax)
ax.set_title('Number of clusters')
plt.show()

tmp = pd.DataFrame.from_records(DBSCAN_params, columns =['Eps', 'Min_samples'])
tmp['Sil_score'] = sil_score

pivot_1 = pd.pivot_table(tmp, values='Sil_score', index='Min_samples', columns='Eps')

fig, ax = plt.subplots(figsize=(18,6))
sns.heatmap(pivot_1, annot=True, annot_kws={"size": 10}, cmap="YlGnBu", ax=ax)
plt.show()

DBS_clustering = DBSCAN(eps=12.25, min_samples=5).fit(X_DBSCAN)

# Menghitung indeks Davies-Bouldin
davies_bouldin = davies_bouldin_score(X_DBSCAN, DBS_clustering.labels_)

print("Indeks Davies-Bouldin:", davies_bouldin)

# Menghitung jumlah kemunculan setiap label
unique_labels_dbscan, counts_dbscan = np.unique(DBS_clustering.labels_, return_counts=True)
bar(unique_labels_dbscan,counts_dbscan)

# Menghitung Variance untuk setiap cluster
variance_dbscan_list = []
for label in unique_labels_dbscan:
    cluster_points = X_DBSCAN[DBS_clustering.labels_ == label]
    centroid = cluster_points.mean(axis=0)
    variance = np.mean(np.sum((cluster_points - centroid) ** 2, axis=1))
    variance_dbscan_list.append(variance)

print(f'Variance for {cluster} clusters: {variance_dbscan_list}')
print(f'Average Variance: {np.mean(variance_dbscan_list)}')

dbscan = DBSCAN(eps=12.25, min_samples=5)
dbscan.fit(X_DBSCAN)

# Get cluster labels
labels = dbscan.labels_

# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)

# Print number of clusters
print('Estimated number of clusters: %d' % n_clusters_)

# Print number of noise points
n_noise_ = list(labels).count(-1)
print('Estimated number of noise points: %d' % n_noise_)

# Calculate density of each cluster
for cluster_label in set(labels):
    if cluster_label != -1:
        cluster_points = X[labels == cluster_label]
        centroid = np.mean(cluster_points, axis=0)
        variance = np.var(cluster_points, axis=0)
        density = len(cluster_points) / np.prod(variance)
        print('Cluster', cluster_label, '- Density:', density)

DBSCAN_clustered = X_DBSCAN.copy()
DBSCAN_clustered.loc[:,'Cluster'] = DBS_clustering.labels_ # menggabungkan label ke DF
dbscan_score = silhouette_score(X_DBSCAN, DBS_clustering.labels_)
print("DBSCAN Silhouette Score : ",dbscan_score)

DBSCAN_clust_sizes = DBSCAN_clustered.groupby('Cluster').size().to_frame()
DBSCAN_clust_sizes.columns = ["DBSCAN_size"]
DBSCAN_clust_sizes

outliers = DBSCAN_clustered[DBSCAN_clustered['Cluster']==-1]

fig2, (axes) = plt.subplots(1,2,figsize=(12,5))


sns.scatterplot(x='Profile_mean', y='Profile_skewness',
                data=DBSCAN_clustered[DBSCAN_clustered['Cluster']!=-1],
                hue='Cluster', ax=axes[0], palette='Set1', legend='full', s=45)

sns.scatterplot(x='Profile_skewness', y='Profile_kurtosis',
                data=DBSCAN_clustered[DBSCAN_clustered['Cluster']!=-1],
                hue='Cluster', palette='Set1', ax=axes[1], legend='full', s=45)

axes[0].scatter(outliers['Profile_mean'], outliers['Profile_skewness'], s=5, label='outliers', c="k")
axes[1].scatter(outliers['Profile_skewness'], outliers['Profile_kurtosis'], s=5, label='outliers', c="k")
axes[0].legend()
axes[1].legend()

plt.setp(axes[0].get_legend().get_texts(), fontsize='10')
plt.setp(axes[1].get_legend().get_texts(), fontsize='10')

plt.show()

"""Agglomerative silhouette Score 0.76

DBSCAN silhouette Score 0.37
"""

from sklearn.metrics import adjusted_rand_score
# Calculate F-measure using 'macro' average
f_measure_weighted = f1_score(ground_truth_labels, DBS_clustering.labels_, average='weighted')
print("F-measure (weighted):", f_measure_weighted)

report = classification_report(ground_truth_labels, DBS_clustering.labels_)

print("Report:")
print(report)
ari = adjusted_rand_score(ground_truth_labels, DBS_clustering.labels_)

print("Adjusted Rand Index (ARI):", ari)

"""# Perbandingan

**Hasil**

pada dataset .. , dihasilkan :

Silhouette Agglomerative : 0.77
Akurasi Agglomerative : 0.55

Silhouette DBSCAN        : 0.37
Akurasi DBSCAN : 0.89
"""

clusters = pd.concat([AGG_clust_sizes, DBSCAN_clust_sizes],axis=1, sort=False)
clusters