# -*- coding: utf-8 -*-
"""Clustering - Kelompok 5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1okLs-SFPUsqehPNRLF_3EG-Y-ZzfMsKF

UCI Dataset IRIS : https://archive.ics.uci.edu/dataset/53/iris

Library
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.cluster import AgglomerativeClustering
from sklearn.preprocessing import StandardScaler, normalize
from sklearn.metrics import silhouette_score
import scipy.cluster.hierarchy as shc
import seaborn as sns
from sklearn.cluster import DBSCAN
from sklearn import metrics
from sklearn.preprocessing import StandardScaler
from sklearn import datasets
from sklearn.metrics import f1_score, classification_report
from sklearn.metrics import confusion_matrix
from sklearn.metrics import davies_bouldin_score
from sklearn.preprocessing import LabelEncoder
from itertools import product

"""# Import Dataset

Import dataset
"""

# import dataset
X = pd.read_csv('iris.csv')
ground_truth_labels = X.iloc[:, -1]

# Menggunakan LabelEncoder untuk mengonversi string kategori menjadi angka
label_encoder = LabelEncoder()
ground_truth_labels = label_encoder.fit_transform(ground_truth_labels)

X = X.drop(columns=[X.columns[-1]])

# ground_truth_labels = X[["class"]]
# X = X.drop(columns=["class"])

# header_info = [
#     "Profile_mean", "Profile_stdev", "Profile_skewness", "Profile_kurtosis", "DM_mean", "DM_stdev", "DM_skewness", "DM_kurtosis"
# ]
# X.columns = header_info

# X_DBSCAN = X[["Profile_mean",'Profile_stdev',"DM_mean",'DM_stdev']]

# Handling the missing values
X.fillna(method ='ffill', inplace = True)

X

ground_truth_labels

X.describe()

X.info()

# Scatter
plt.figure(figsize =(6, 6))
plt.scatter(X['sepal length'], X['sepal width'])
plt.show()
plt.figure(figsize =(6, 6))
plt.scatter(X['petal length'], X['petal width'])
plt.show()

# # Scaling the data so that all the features become comparable
# scaler = StandardScaler()
# X_scaled = scaler.fit_transform(X)

# # Normalizing the data so that the data approximately
# # follows a Gaussian distribution
# X_normalized = normalize(X_scaled)

# # Converting the numpy array into a pandas DataFrame
# X_normalized = pd.DataFrame(X_normalized)

# pca = PCA(n_components = 2)
# X_principal = pca.fit_transform(X)
# X_principal = pd.DataFrame(X_principal)
# X_principal.columns = ['P1', 'P2']

# X_DBSCAN = X_principal.copy()


# X_principal

# plt.figure(figsize =(6, 6))
# plt.scatter(X_principal['P1'], X_principal['P2'])
# plt.show()

"""# Agglomerative Clustering"""

# dendrogram
plt.figure(figsize =(8, 8))
plt.title('Visualising the data')
Dendrogram = shc.dendrogram((shc.linkage(X, method ='ward')))

"""**Cluster Agglomerative**"""

agglo_labels = []
agglo_dbIndex = []

for cluster in range(2,7):
  print("Cluster ", cluster)
  ac2 = AgglomerativeClustering(n_clusters = cluster)
  agglomerative_labels = ac2.fit_predict(X)
  agglomerative_score = silhouette_score(X, agglomerative_labels)
  agglo_labels.append(agglomerative_labels)
  # Buat figure dengan 2 subplot berdampingan
  fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

  # Plot scatter pada subplot pertama (ax1)
  scatter = ax1.scatter(X['sepal length'], X['sepal width'], c=agglomerative_labels, cmap='rainbow')
  ax1.set_title("Scatter Plot of Clusters")
  ax1.set_xlabel("sepal length")
  ax1.set_ylabel("sepal width")

  # Menghitung Davies-Bouldin Index
  db_index = davies_bouldin_score(X, agglomerative_labels)
  agglo_dbIndex.append(db_index)

  # Menghitung jumlah kemunculan setiap label
  unique_labels, counts = np.unique(agglomerative_labels, return_counts=True)
  ax2.bar(unique_labels, counts, color=plt.cm.rainbow(np.linspace(0, 1, len(unique_labels))))
  ax2.set_title("Distribution Of The Clusters")
  ax2.set_xlabel("Cluster Labels")
  ax2.set_ylabel("Count")
  ax2.set_xticks(unique_labels)  # Set x-ticks sesuai dengan label yang unik

  # Tampilkan plot
  plt.tight_layout()
  plt.show()

  # Menghitung Variance untuk setiap cluster
  variance_list = []
  for label in unique_labels:
      cluster_points = X[agglomerative_labels == label]
      centroid = cluster_points.mean(axis=0)
      variance = np.mean(np.sum((cluster_points - centroid) ** 2, axis=1))
      variance_list.append(variance)

  print(f'Variance for {cluster} clusters: {variance_list}')
  print(f'Average Variance: {np.mean(variance_list)}')
  print("")

AGG_clustered = X.copy()
AGG_clustered.loc[:,'Cluster'] = agglo_labels[0] # menggabungkan label ke DF
AGG_clust_sizes = AGG_clustered.groupby('Cluster').size().to_frame()
AGG_clust_sizes.columns = ["AGG_size"]
AGG_clust_sizes

AGG_clustered

k = [2, 3, 4, 5, 6]

# Plotting graph untuk membandingkan cluster n 2-6
print("David Boundin Index : ")
plt.bar(k, agglo_dbIndex)
plt.xlabel('Number of clusters', fontsize = 20)
plt.ylabel('DB Index', fontsize = 20)
plt.show()

print("Davies-Bouldin Index:", agglo_dbIndex)
# Calculate F-measure using 'macro' average
f_measure_weighted_agglo = f1_score(ground_truth_labels, agglo_labels[1], average='weighted')
print("F-measure (weighted):", f_measure_weighted_agglo)

# Commented out IPython magic to ensure Python compatibility.
# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(agglo_labels[0])) - (1 if -1 in agglo_labels[0] else 0)
n_noise_ = list(agglo_labels[0]).count(-1)
print('Estimated number of clusters: %d' % n_clusters_)
print('Estimated number of noise points: %d' % n_noise_)
print("Homogeneity: %0.3f" % metrics.homogeneity_score(ground_truth_labels, agglo_labels[0]))
print("Completeness: %0.3f" % metrics.completeness_score(ground_truth_labels, agglo_labels[0]))
print("V-measure: %0.3f" % metrics.v_measure_score(ground_truth_labels, agglo_labels[0]))
print("Adjusted Rand Index: %0.3f"
#  % metrics.adjusted_rand_score(ground_truth_labels, agglo_labels[0]))
print("Adjusted Mutual Information: %0.3f"
#  % metrics.adjusted_mutual_info_score(ground_truth_labels, agglo_labels[0]))
print("Silhouette Coefficient: %0.3f"
#  % metrics.silhouette_score(X, agglo_labels[0]))

"""# DBSCAN Clustering

**DBSCAN**
"""

X.head()

eps_values = np.arange(0.2,1.5,0.1) # eps values to be investigated
min_samples = np.arange(3,7) # min_samples values to be investigated

DBSCAN_params = list(product(eps_values, min_samples))

no_of_clusters = []
sil_score = []
db_index = []

for p in DBSCAN_params:
    # Melakukan clustering dengan DBSCAN
    DBS_clustering = DBSCAN(eps=p[0], min_samples=p[1]).fit(X)

    # Menghitung jumlah cluster
    no_of_clusters.append(len(np.unique(DBS_clustering.labels_)))

    # Menghitung Davies-Bouldin Index
    db_index.append(davies_bouldin_score(X, DBS_clustering.labels_))

# Menampilkan hasil evaluasi
print("Jumlah Cluster:", no_of_clusters)
print("Davies-Bouldin Index:", db_index)

tmp = pd.DataFrame.from_records(DBSCAN_params, columns =['Eps', 'Min_samples'])
tmp['No_of_clusters'] = no_of_clusters

pivot_1 = pd.pivot_table(tmp, values='No_of_clusters', index='Min_samples', columns='Eps')

fig, ax = plt.subplots(figsize=(12,6))
sns.heatmap(pivot_1, annot=True,annot_kws={"size": 16}, cmap="YlGnBu", ax=ax)
ax.set_title('Number of clusters')
plt.show()

tmp = pd.DataFrame.from_records(DBSCAN_params, columns =['Eps', 'Min_samples'])
tmp['db_index'] = db_index

pivot_1 = pd.pivot_table(tmp, values='db_index', index='Min_samples', columns='Eps')

fig, ax = plt.subplots(figsize=(18,6))
sns.heatmap(pivot_1, annot=True, annot_kws={"size": 10}, cmap="YlGnBu", ax=ax)
plt.show()

DBS_clustering = DBSCAN(eps=0.5, min_samples=6).fit(X)

# Menghitung indeks Davies-Bouldin
davies_bouldin = davies_bouldin_score(X, DBS_clustering.labels_)

# Menghitung jumlah kemunculan setiap label
unique_labels_dbscan, counts_dbscan = np.unique(DBS_clustering.labels_, return_counts=True)
# bar(unique_labels_dbscan,counts_dbscan)

# Menghitung Variance untuk setiap cluster
variance_dbscan_list = []
for label in unique_labels_dbscan:
    cluster_points = X[DBS_clustering.labels_ == label]
    centroid = cluster_points.mean(axis=0)
    variance = np.mean(np.sum((cluster_points - centroid) ** 2, axis=1))
    variance_dbscan_list.append(variance)

DBSCAN_clustered = X.copy()
DBSCAN_clustered.loc[:,'Cluster'] = DBS_clustering.labels_ # menggabungkan label ke DF
dbscan_score = silhouette_score(X, DBS_clustering.labels_)

# Calculate F-measure using 'macro' average
f_measure_weighted = f1_score(ground_truth_labels, DBS_clustering.labels_, average='weighted')
print("Indeks Davies-Bouldin:", davies_bouldin)
print("F-measure (weighted):", f_measure_weighted)
print(f'Variance for clusters: {variance_dbscan_list}')
print(f'Average Variance: {np.mean(variance_dbscan_list)}')

DBSCAN_clust_sizes = DBSCAN_clustered.groupby('Cluster').size().to_frame()
DBSCAN_clust_sizes.columns = ["DBSCAN_size"]
DBSCAN_clust_sizes

# Menghitung jumlah kemunculan setiap label
unique_labels_dbscan, counts_dbscan = np.unique(DBS_clustering.labels_, return_counts=True)

# Memisahkan outliers
outliers = DBSCAN_clustered[DBSCAN_clustered['Cluster'] == -1]

# Membuat plot samping-sampingan
fig2, axes = plt.subplots(1, 2, figsize=(12, 5))

# Definisikan palet warna
# Gunakan hitam untuk outliers (label -1)
palette = sns.color_palette('Set1', len(unique_labels_dbscan) - 1)
palette = np.vstack(([0, 0, 0], palette))  # Tambahkan hitam di awal untuk label -1

# Buat dictionary untuk pemetaan warna cluster
color_dict = {label: palette[i] for i, label in enumerate(unique_labels_dbscan)}

# Plot scatter pada subplot pertama (sebelah kiri)
sns.scatterplot(x='sepal length', y='sepal width',
                data=DBSCAN_clustered[DBSCAN_clustered['Cluster'] != -1],
                hue='Cluster', ax=axes[0], palette=color_dict, legend='full', s=45)

axes[0].scatter(outliers['sepal length'], outliers['sepal width'], s=5, label='outliers', c="k")
axes[0].legend()
plt.setp(axes[0].get_legend().get_texts(), fontsize='10')

# Plot bar pada subplot kedua (sebelah kanan)
bar_colors = [color_dict[label] for label in unique_labels_dbscan]
axes[1].bar(unique_labels_dbscan, counts_dbscan, color=bar_colors)
axes[1].set_title("Distribution Of The Clusters")
axes[1].set_xlabel("Cluster Labels")
axes[1].set_ylabel("Count")
axes[1].set_xticks(unique_labels_dbscan)

# Menampilkan plot
plt.tight_layout()
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# Number of clusters in labels, ignoring noise if present.
n_clusters_ = len(set(DBS_clustering.labels_)) - (1 if -1 in DBS_clustering.labels_ else 0)
n_noise_ = list(DBS_clustering.labels_).count(-1)
print('Estimated number of clusters: %d' % n_clusters_)
print('Estimated number of noise points: %d' % n_noise_)
print("Homogeneity: %0.3f" % metrics.homogeneity_score(ground_truth_labels, DBS_clustering.labels_))
print("Completeness: %0.3f" % metrics.completeness_score(ground_truth_labels, DBS_clustering.labels_))
print("V-measure: %0.3f" % metrics.v_measure_score(ground_truth_labels, DBS_clustering.labels_))
print("Adjusted Rand Index: %0.3f"
 % metrics.adjusted_rand_score(ground_truth_labels, DBS_clustering.labels_))
print("Adjusted Mutual Information: %0.3f"
 % metrics.adjusted_mutual_info_score(ground_truth_labels, DBS_clustering.labels_))
print("Silhouette Coefficient: %0.3f"
 % metrics.silhouette_score(X, DBS_clustering.labels_))

"""# Perbandingan"""

clusters = pd.concat([AGG_clust_sizes, DBSCAN_clust_sizes],axis=1, sort=False)
clusters

print("Davies Bouldin Index Agglomerative : ", agglo_dbIndex[0])
print("Davies Bouldin Index DBSCAN : ", davies_bouldin)

# Membuat plot
fig2, axes = plt.subplots(1, 2, figsize=(12, 5))

# Plot scatter pada subplot pertama (sebelah kiri)
sns.scatterplot(x='sepal length', y='sepal width',
                data=DBSCAN_clustered[DBSCAN_clustered['Cluster'] != -1],
                hue='Cluster', ax=axes[0], legend='full', s=45)
axes[0].scatter(outliers['sepal length'], outliers['sepal width'], s=5, label='outliers', c="k")
axes[0].legend()
axes[0].set_title("DBSCAN Clustering")

sns.scatterplot(x='sepal length', y='sepal width',
                data=X,
                hue= agglo_labels[0] , ax=axes[1], legend='full', s=45)
axes[1].set_title("Agglomerative Clustering")

plt.show()